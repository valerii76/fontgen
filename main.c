/*
 * =====================================================================================
 *
 *       Filename:  main.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  06/28/2012 09:40:00 AM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Valery Volgutov (Valery Volgutov), valery.volgutov@lge.com
 *        Company:  LGE
 *
 * =====================================================================================
 */

#include "config.h"
#include <stdio.h>

#include <ft2build.h>
#include FT_FREETYPE_H

#include <freetype/ftglyph.h>

void fontgen_log (char const *format, ...)
{
    va_list args;
    va_start (args, format);

    vprintf (format, args);
    printf ("\n");

    va_end (args);
}

#define TO_STR(x) #x

#define CHECK_FT(exp) \
{\
    FT_Error err = (exp);\
    if (err) \
    {\
        printf (TO_STR (FreeType error <<exp>>: 0x%x\n), err);\
        return -1;\
    }\
}

FT_Library g_library;
FT_Face g_face;

int compare (const void* a, const void *b)
{
    return (*(char*) a - *(char*) b);
}

struct cmd_opts
{
    char *font_path;
    int font_size;
    char *sample;
    char *name;

    char display: 1;
    char rotate: 1;
};

void print_help (void)
{
    printf ("Program using for generate font data for given font and font sample\n"
            "\nFormat output:\n"
            "\tfirst byte of data - number of chars\n"
            "\tlast byte of data - average width of all chars\n"
            "\t'A' - code of char\n"
            "\t0x45 - size of char 01        001001\n"
            "\t                    --        ------\n"
            "\t                num of rows | num of cols\n"
            "\t                  (8 bits)\n"
            "\tall data for this char\n");

    printf ("\nusage: fontgen [options] <font path> <size> <sample>\n");
    printf ("options:\n"
            "\t--version:\tprogram version\n"
            "\t--name:\t name for generated array\n"
            "\t-d --display:\tdisplay sample to stdout\n"
            "\t-r --rotate:\trotate font data\n");
}

int parse_cmd (int argc, char *argv[], struct cmd_opts *opts)
{
    int i = 1;
    int req_params = 0;
    int wait_param = 0;

    memset (opts, 0, sizeof (struct cmd_opts));

    for (; i < argc; ++i)
    {
        if (!req_params &&
            (!strcmp (argv [i], "--name") || wait_param == 1))
        {
            if (wait_param)
            {
                opts->name = argv [i];
                wait_param = 0;
            }
            else
                wait_param = 1;
        }
        else if (!req_params &&
                 (!strcmp (argv [i], "-d") || !strcmp (argv [i], "--display")))
        {
            opts->display = 1;
        }
        else if (!req_params &&
                 (!strcmp (argv [i], "-r") || !strcmp (argv [i], "--rotate")))
        {
            opts->rotate = 1;
        }
        else if (!strcmp (argv [i], "--version"))
        {
            printf ("fontgen: version %d.%d\n", MAJOR_VERSION, MINOR_VERSION);
            return 0;
        }
        else if (req_params == 0)
        {
            opts->font_path = argv [i];
            ++req_params;
        }
        else if (req_params == 1)
        {
            opts->font_size = atoi (argv [i]);
            if (opts->font_size == 0)
            {
                printf ("invalide font size: %s\n", argv[i]);
                print_help ();
                return 0;
            }
            ++req_params;
        }
        else if (req_params == 2)
        {
            opts->sample = argv [i];
        }
    }

    if (req_params != 2)
    {
        printf ("invalid command line\n");
        print_help ();
        return 0;
    }

    return 1;
}

int main (int argc, char *argv[])
{
    int i, j, k;
    FT_Bitmap *bitmap = NULL;
    FT_BitmapGlyph bm_glyph;
    FT_Glyph glyph;
    FT_Int index;

    int font_size = 8;
    int total_bytes = 0;
    char const *font_name = NULL;
    char *font_sample = NULL;
    int sample_len;
    float space = 0;
    struct cmd_opts options;

    if (!parse_cmd (argc, argv, &options))
    {
        return 1;
    }

    font_name = options.font_path;
    font_size = options.font_size;
    font_sample = options.sample;
    sample_len = strlen (font_sample);

    qsort (font_sample, strlen (font_sample), sizeof (char), compare);

    {
        int i = 0;
        for (; i < sample_len; ++i)
            if (font_sample [i] == ' ')
                --sample_len;
    }

    CHECK_FT (FT_Init_FreeType (&g_library));
    CHECK_FT (FT_New_Face (g_library, font_name, 0, &g_face));

    CHECK_FT (FT_Set_Char_Size (g_face, 0, font_size << 6, 300, 300));
    CHECK_FT (FT_Set_Pixel_Sizes (g_face, 0, font_size));

    if (!options.display)
    {
        fontgen_log ("/* autogenerated fontgen (Valery Volgutov) */");
        fontgen_log ("unsigned char const %s%d [] = {\n    %d,",
                options.name ? options.name : g_face->family_name, font_size, sample_len);
    }

    for (i = 0; i < strlen (font_sample); ++i)
    {
        int h, hh;

        if (font_sample [i] == ' ')
            continue;

        index = FT_Get_Char_Index (g_face, font_sample[i]);
        CHECK_FT (FT_Load_Glyph (g_face, index, FT_LOAD_TARGET_MONO));
        CHECK_FT (FT_Get_Glyph (g_face->glyph, &glyph));

        CHECK_FT (FT_Glyph_To_Bitmap (&glyph, FT_RENDER_MODE_MONO, 0, 1));
        bm_glyph = (FT_BitmapGlyph)glyph;
        bitmap = &bm_glyph->bitmap;

        if (!options.display)
        {
            h = (bitmap->rows >> 3) + (bitmap->rows & 0x7 ? 1 : 0);

            space += bitmap->width & 0x3F;

            printf ("    '%c', 0x%x, ", font_sample[i], ((h << 6) | (bitmap->width & 0x3F)));
            total_bytes += 2;

            for (hh = 0; hh < h; ++hh)
            {
                int rows = hh < (h - 1) ? 8 : (bitmap->rows & 0x7);
                for (k = 0; k < bitmap->width; ++k)
                {
                    unsigned char b = 0;
                    for (j = 0; j < rows; ++j)
                    {
                        int idx = k & 0x07;
                        unsigned char buf = bitmap->buffer[(j + (hh << 3)) * bitmap->pitch + (k >> 3)];
                        b |= ((buf & (1 << (7 - idx))) >> (7 - idx)) << (j & 0x7);
                    }
                    printf ("0x%x, ", b);
                    ++total_bytes;
                }
            }
            printf ("\n");
        }
        else
        {

            for (j = 0; j < bitmap->rows; ++j)
            {
                int w = 0;
                int wb = bitmap->width / 8 + (bitmap->width & 0x7 ? 1 : 0);
                for (w = 0; w < wb; ++w)
                {
                    int k = 8;
                    int b = bitmap->buffer[j * bitmap->pitch + w];
                    while (k--)
                    {
                        if ((b & 0x80))
                            printf ("*");
                        else
                            printf (" ");
                        b <<= 1;
                    }
                }
                printf ("\n");
            }
        }

        FT_Done_Glyph (glyph);
    }

    if (!options.display)
    {
        /* add space value - always last element (has only one number (move pos to next position))*/
        space /= strlen (font_sample);
        fontgen_log ("    %d, /* space value always last element */", (int)space);
        ++total_bytes;
        fontgen_log ("}; /* Total bytes: %d */", total_bytes);
    }

    CHECK_FT (FT_Done_Face (g_face));
    CHECK_FT (FT_Done_FreeType (g_library));
    return 0;
}
